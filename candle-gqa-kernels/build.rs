fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/compatibility.cuh");
    println!("cargo:rerun-if-changed=src/cuda_utils.cuh");
    println!("cargo:rerun-if-changed=src/binary_op_macros.cuh");

    let target_os = std::env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();
    if target_os == "macos" {
        // No CUDA on macOS: provide a stub so the crate compiles and is a no-op.
        let stub = r#"// Auto-generated by build.rs for macOS (no CUDA available)
pub const UNARY: &str = "";
"#;
        std::fs::write("src/lib.rs", stub)
            .expect("failed to write macOS stub for candle-gqa-kernels");
        println!("cargo:warning=CUDA kernels are stubbed on macOS; this crate will be a no-op.");
        return;
    }

    // Try to build PTX. If it fails (e.g. CUDA not installed), fall back to stub to avoid
    // breaking workspace builds and rust-analyzer.
    let builder = bindgen_cuda::Builder::default();
    println!("cargo:info={builder:?}");
    match builder.build_ptx() {
        Ok(bindings) => {
            bindings
                .write("src/lib.rs")
                .expect("failed to write generated CUDA bindings");
        }
        Err(err) => {
            println!(
                "cargo:warning=Failed to build CUDA PTX ({:?}). Falling back to stub.",
                err
            );
            let stub = r#"// Auto-generated fallback by build.rs (CUDA/PTX generation failed)
pub const UNARY: &str = "";
"#;
            std::fs::write("src/lib.rs", stub)
                .expect("failed to write fallback stub for candle-gqa-kernels");
        }
    }
}
